# Overview

I _think_ I understand the concept of the code, but the implementation confuses
me at times

# Initialization

* DRIZZLE_INITIALIZING
    * getWeb3
    * getNetwork
    * getAccounts
    * getAccountBalances
    * LOOP ... for each contract
      * ADD_CONTRACT
        * CONTRACT_INITIALIZING
          * LISTEN_FOR_EVENT (when a drizzleContract is instanciated) hooks into
              web3 listener for contract event
        * CONTRACT_INITIALIZED
    *  BLOCKS_POLLING || BLOCKS_LISTENING depending on options.polls
* DRIZZLE_INITIALIZED || DRIZZLE_FAILED


## transactions

The slot (Array) DS to track transactions, didn't initially have a state for
outgoing. This was difficult to reconcile failed transactions. (fixed)


## Classes

### Drizzle is a class that exposes:
  * a guard to make sure the environment (node, native, browser) is
      loaded and ready to continue.
  * the `addContract` method.


constructor(options, store) takes `drizzleOptions` & a `reduxStore`

State:
  * `contracts`: a hash that maps `contractName` -> `DrizzleContract`
  * `contractList`: an array of `DrizzleContract`
  * `option`: passed in `drizzleOptions`
  * `store`: the provided store, or one that's generated from options
  * `web3`:  Is not utilized in the Drizzle class module, though it might be
           used in caller modules.

#### Methods

  * addContract(contractConfig, events=[]) adds a contract be monitored. It does
      this by dispatching the ADD_CONTRACT action to Store.
      * State
        * type: ADD_CONTRACT
        * drizzle: this context
        * contractConfig: param from addContract  [is this value different for
            truffle contracts vs contracts recovered from web3?]
        * events: param from addContract
        * web3: this.web3 -- this is set to web3 after getWeb3Saga is resolved

      * Note. This method should check to see that drizzle has been initialized
              before commencing. If not initialized then it should throw an
              error.

  * _addContract(drizzleContract)
  * generateStore - not sure what this does, the comment implies backwards
      compatibility. Is it still needed? Do we want to maintain compatibility?


##### CallStack
```
  addContract ({ drizzle, contractConfig, events, web3 })
    drizzleContract =\
                     |
                     v
    [if contractConfig.web3Contract]
      // if contract artifacts are from web3?
      instantiateWeb3Contract ({ web3Contract: contractConfig.web3Contract,
                                 name: contractConfig.web3ContractName,
                                 events,
                                 store: drizzle.store,
                                 web3
                              })
    [else...]
      // if contract artifacts are from truffle?
      instantiateContract({ contractArtifact: contractConfig,
                            events,
                            store: drizzle.store,
                            web3
                          })

    _addContract
```



#### Actions dispatched:
  * DRIZZLE_INITIALIZING -> after the environment is loaded
  * ADD_CONTRACT -> when `addContract` is invoked


#### Questions:

  * addContract is invoked with contractConfig and events while _addContract is
    called with a drizzleContract. What is the difference between a
    contractConfig and a drizzleContract?

    drizzleContract - web3Contract + cacheCall + cacheSend + generateArgsHash
    generateArgs Hash doesn't need to be available for every contract
    contractConfig - drizzle artifact file || manuallly created web3 contact

  * this.web3 set to the empty object {} in the drizzle instance, but is passed
      along to instantiateContract or instantiateWeb3Contract. Not sure why this
      doesn't blow up.
      Nevermind: This is set in drizzleStatusSaga after initializeWeb3 has been
      resolved.


## Unreferenced modules
getAddress.js -- can be deleted


## Can be refactored and combined into a utility module

src/getAbi.js
src/generateContractInitialState.js
  : forEach abi
  : set state to {} if item.type == function && item.constant
  : else state to {initialized: false, synced: false}

src/generateContractsInitialState.js
  : forEach contract -> generateContractInitialState

src/mergeOptions.js
  : has one function that looks like it can be moved to utility, or replaced with
    Ramda::mergeRight (or variant) [See Function Trace](./mergeOptions.md)


# Web3 In general

1. Do we need to support pre web3 1.0? Would be nice to eliminate polling.


# State Concerns

The state object seems to keep track of truffle-artificts that are unused by
drizzle and incur a cost to track and diff. If transformed truffle-artifacts to
onley the pieces we need to interact with web3 - we will have a smaller state,
and could do more efficient optimizations that rely on comparisons/diffs for UI.


# Block Polling and Listening
The
